# REST API

## `net/http`

The `net/http` package is part of Go's standard library and provides functions for building HTTP servers and clients. It is commonly used for creating web servers, handling HTTP requests and responses, and managing various aspects of HTTP communication.

Key Features of `net/http`:

* **HTTP Server**: It provides utilities to create and run an HTTP server.
* **HTTP Client**: It also allows making HTTP requests (GET, POST, etc.) to other servers.
* **Routing**: It offers basic routing through the `http.HandleFunc()` function, where you can map URLs to specific handler functions.
* **Request and Response Handling**: It provides structures like `http.Request` and `http.Response` for working with HTTP requests and responses.

## `github.com/gin-gonic/gin`

Gin is a web framework for Go that builds on `net/http` and provides a more feature-rich, higher-level API for building web applications and APIs. It is designed for speed and flexibility and is commonly used in Go projects requiring web services.

Key Features of Gin:

* **Routing**: Offers a more advanced and easier routing system compared to `net/http`.
* **Middleware**: Supports adding middleware functions that can be executed before or after the main handler, enabling logging, authorization, and other features.
* **JSON Handling**: Makes working with JSON more convenient, especially for building RESTful APIs.
* **Error Handling**: Simplifies error handling and returns structured responses.
* **Performance**: Gin is one of the fastest web frameworks for Go, as it is built for high-performance applications.

### `go get -u github.com/gin-gonic/gin`

* Use the above command to download and install `gin` package.
* `-u` stands for update. It ensures that all the dependencies of the package are updated. This can include transitive dependencies.
* When the above command is run, it adds the package and its dependencies to the `require` section of the `go.mod` file.
* It also updates (or creates if does not exist) the `go.sum` file.
  * The `go.sum` file is used by Go to ensure the integrity and security of dependencies in a Go project. It is automatically created and maintained by Go when you run commands like `go get`, `go build`, or `go mod tidy`. The primary purpose of the `go.sum` file is to store cryptographic hashes of the content of dependencies, helping verify that the downloaded dependencies have not been tampered with.

## API Testing With REST Client

* Install "REST Client" VS Code extension.
* Create a folder in the project to have all the tests in it. For example, `api-test` folder.
* Create a `http` file in the folder. For example, `create-event.http` file. REST Client extension will identify these files and help do the testing.

```http
POST http://localhost:8080/events
content-type: application/json

{
  "name": "Test event",
  "description": "A test event",
  "location": "A test location",
  "dateTime": "2025-01-01T15:30:00.000Z"
}
```

* Once a `http` file is created, there should be a "Send Request" link/button right above the request URL generated by the extension. This can be clicked to test the endpoint while the server is running.
* The empty line after the `content-type` field is important.

## Prepare() vs Exec()/Query()

Preparing statements vs Directly executing queries:

* `DB.Exec()` - when we want to create a table
* `Prepare()` + `stmt.Exec()` - when we want to insert data into the database
* `DB.Query` - when we want to fetch data from the database

`Exec()` or `Query()` commands could be used instead of using `Prepare()`. The difference between these two methods is just whether the data is being fetched from the database or the database is being manipulated.

But what's the advantage of using `Prepare()`?

`Prepare()` prepares an SQL statement â€“ this can lead to better performance if the same statement is executed multiple times (potentially with different data for its placeholders). This is only true if the prepared statement is not closed (stmt.Close()) in between those executions. In that case, there wouldn't be any advantageous.

## Middleware Folder

In a Go project, the middleware folder typically contains the code for middleware functions that are used to handle HTTP requests before they reach the main business logic of the application. Middleware functions can be used for tasks like authentication, logging, error handling, request validation, rate limiting, and more. These functions are usually added to the HTTP request-response cycle to modify or inspect the request and response.

### AbortWithStatusJSON()

In the Gin web framework, the `AbortWithStatusJSON()` method is used to stop the normal flow of request handling, preventing subsequent handlers or middleware from being executed. It immediately sends a JSON response with a specific HTTP status code. This is useful for scenarios where the request needs to be aborted from processing, typically after an error has occurred, and return a custom response (e.g., 400 for bad request, 401 for unauthorized).

### Usage of Middleware

*The `Authenticate` middleware from the `11-rest-api` project will be used as an example here.*

One way of registering the `Authenticate` middleware to a request handler is to use it like below:

```go
server.POST("/events", middleware.Authenticate, createEvent)
```

In this case, the functions will be executed in left to right order. So, if a user is not authenticated, the handle will abort the request and the `createEvent` function will not be reached. But this needs to added to all the individual request handler that will be using this middleware.

An alternative approach for this usage will be using `server.Group()` function. `Group()` creates a new router group. All the routes that have common middlewares or the same path prefix should be using this fucntion. For example, all the routes that use a common middleware for authorization could be grouped.

```go
// "/" is the common prefix for all the routes that will using the Authenticate middleware
authenticated := server.Group("/")  
authenticated.Use(middleware.Authenticate)
authenticated.POST("/events", createEvent)
authenticated.PUT("/events/:id", updateEvent)
authenticated.DELETE("/events/:id", deleteEvent)
```
